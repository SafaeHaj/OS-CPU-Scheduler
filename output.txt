./
./.gitignore
.vscode/ 

./.vscode/
./.vscode/c_cpp_properties.json
{
  "configurations": [
    {
      "name": "windows-gcc-x64",
      "includePath": [
        "${workspaceFolder}/**"
      ],
      "defines": [
        "_DEBUG",
        "UNICODE",
        "_UNICODE"
      ],
      "compilerPath": "C:/Users/MANSOUB YAHYA/Documents/winlibs-x86_64-posix-seh-gcc-14.2.0-llvm-19.1.1-mingw-w64ucrt-12.0.0-r2/mingw64/bin/gcc.exe",
      "cStandard": "${default}",
      "cppStandard": "${default}",
      "intelliSenseMode": "windows-gcc-x64"
    }
  ],
  "version": 4
}
./.vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "C/C++ Runner: Debug Session",
      "type": "cppdbg",
      "request": "launch",
      "args": [],
      "stopAtEntry": false,
      "externalConsole": true,
      "cwd": "c:/Users/MANSOUB YAHYA/Desktop/GitHub/OS-CPU-Scheduler/include",
      "program": "c:/Users/MANSOUB YAHYA/Desktop/GitHub/OS-CPU-Scheduler/include/build/Debug/outDebug",
      "MIMode": "gdb",
      "miDebuggerPath": "gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ]
    }
  ]
}
./.vscode/settings.json
{
  "files.associations": {
    "*.page-template": "vue",
    "*.layout-template": "vue",
    "*.vue": "vue",
    "numeric": "cpp",
    "algorithm": "cpp"
  },
  "C_Cpp_Runner.cCompilerPath": "gcc",
  "C_Cpp_Runner.cppCompilerPath": "g++",
  "C_Cpp_Runner.debuggerPath": "gdb",
  "C_Cpp_Runner.cStandard": "",
  "C_Cpp_Runner.cppStandard": "",
  "C_Cpp_Runner.msvcBatchPath": "C:/Program Files/Microsoft Visual Studio/VR_NR/Community/VC/Auxiliary/Build/vcvarsall.bat",
  "C_Cpp_Runner.useMsvc": false,
  "C_Cpp_Runner.warnings": [
    "-Wall",
    "-Wextra",
    "-Wpedantic",
    "-Wshadow",
    "-Wformat=2",
    "-Wcast-align",
    "-Wconversion",
    "-Wsign-conversion",
    "-Wnull-dereference"
  ],
  "C_Cpp_Runner.msvcWarnings": [
    "/W4",
    "/permissive-",
    "/w14242",
    "/w14287",
    "/w14296",
    "/w14311",
    "/w14826",
    "/w44062",
    "/w44242",
    "/w14905",
    "/w14906",
    "/w14263",
    "/w44265",
    "/w14928"
  ],
  "C_Cpp_Runner.enableWarnings": true,
  "C_Cpp_Runner.warningsAsError": false,
  "C_Cpp_Runner.compilerArgs": [],
  "C_Cpp_Runner.linkerArgs": [],
  "C_Cpp_Runner.includePaths": [],
  "C_Cpp_Runner.includeSearch": [
    "*",
    "**/*"
  ],
  "C_Cpp_Runner.excludeSearch": [
    "**/build",
    "**/build/**",
    "**/.*",
    "**/.*/**",
    "**/.vscode",
    "**/.vscode/**"
  ],
  "C_Cpp_Runner.useAddressSanitizer": false,
  "C_Cpp_Runner.useUndefinedSanitizer": false,
  "C_Cpp_Runner.useLeakSanitizer": false,
  "C_Cpp_Runner.showCompilationTime": false,
  "C_Cpp_Runner.useLinkTimeOptimization": false,
  "C_Cpp_Runner.msvcSecureNoWarnings": false,
  "C_Cpp.errorSquiggles": "disabled"
}
./include/
./include/build/
./include/build/Debug/
./include/InputHandler.h
#ifndef INPUT_HANDLER_H
#define INPUT_HANDLER_H

#include <vector>
#include <string>
#include "Process.h"

class InputHandler {
public:
    // Read processes from file
    static std::vector<Process> readFromFile(const std::string& filename);
    
    // Generate random processes
    static std::vector<Process> generateRandomProcesses(int count,
                                                      int max_arrival,
                                                      int min_burst,
                                                      int max_burst,
                                                      int max_priority);
};

#endif // INPUT_HANDLER_H
./include/Process.h
#ifndef PROCESS_H
#define PROCESS_H


class Process {
  private:
  int id;
  int arrival_time;
  int burst_time;
  int priority;
  int remaining_time;
  int waiting_time;
  int turnaround_time;
  int completion_time;


  public:

  Process(int id, int at, int bt, int prio);

  // Getters 

    int getId() const;
    int getArrivalTime() const;
    int getBurstTime() const;
    int getPriority() const;
    int getRemainingTime() const;
    int getWaitingTime() const;
    int getTurnaroundTime() const;
    int getCompletionTime() const;


};







#endif // PROCESS_H
./include/Scheduler.h
#include <vector>
#include <unordered_map>
#include "Process.h"

class Scheduler {
    protected:
        std::vector<Process> processes;  
        Process* current_process = nullptr;
        int current_time = 0;
        Metrics metrics;

    public:
        virtual void schedule() = 0; // virtual method that will be overridden in derived classes
        void run_simulation();        
        void calculate_metrics(); // to define later on     
    };


    struct Metrics {
        struct ProcessStats {
            int waiting_time;
            int turnaround_time;
        };
    
        float avg_waiting_time;
        float avg_turnaround_time;
        float cpu_utilization;
        int total_idle_time;
    
        std::unordered_map<int, ProcessStats> process_details;
    
        void reset() {
            avg_waiting_time = 0.0f;
            avg_turnaround_time = 0.0f;
            cpu_utilization = 0.0f;
            total_idle_time = 0;
            process_details.clear();
        }
    };
./Makefile
# empty for now
# but will be used to build the project
# and run tests
./output.txt
./README.md
# OS CPU Scheduler

This repository contains the first assignment for the Operating Systems course, focusing on CPU scheduling algorithms. It includes implementations of:

- First-Come-First-Served (FCFS)
- Shortest Job First (SJF)
- Priority Scheduling
- Round Robin (RR)
- Round Robin with Priority (RR + Priority)

## Objectives

- Understand and compare scheduling algorithms.
- Implement and simulate their behavior.
- Analyze performance metrics: turnaround time, waiting time, and CPU utilization.

Students: Safae Hajjout & Yahya Mansoub
./src/
./src/FCFS.cpp
#include "Scheduler.h"
#include <vector>
#include <algorithm> // for std::sort



class FCFS : public Scheduler {
    public: 
    void schedule() override {
        // Let's sort the processes vector by arrival time
        std :: sort(processes.begin(), processes.end(),
    [](const Process& a , const Process& b) {
        return a.getArrivalTime() < b.getArrivalTime();
    });
    current_time = 0;
    for (auto& p : processes){

        // Handle the CPU idle time
        if (current_time < p.getArrivalTime()){
            metrics.total_idl_time += p.getArrivalTime() - current_time;
            current_time = p.getArrivalTime();
        }
        p.updateWaitingTime(current_time - p.getArrivalTime());
        current_time += p.getBurstTime();
        p.setCompletionTime(current_time);

        Metrics:: ProcessStats stats;

        stats.waiting_time = p.getWaitingTime();
        stats.turnaround_time = p.getTurnaroundTime();
        metrics.process_details[p.getId()] = stats;
    }
    calculate_metrics();
    }
};
./src/InputHandler.cpp
#include "InputHandler.h"
#include <fstream>
#include <sstream>
#include <random>
#include <stdexcept>

std::vector<Process> InputHandler::readFromFile(const std::string& filename) {
    std::vector<Process> processes;
    std::ifstream file(filename);
    std::string line;

    while (std::getline(file, line)) {
        std::istringstream iss(line);
        int id, at, bt, prio;
        
        if (!(iss >> id >> at >> bt >> prio)) {
            throw std::runtime_error("Invalid input format in file");
        }

        if (at < 0 || bt <= 0 || prio < 0) {
            throw std::runtime_error("Invalid process parameters");
        }

        processes.emplace_back(id, at, bt, prio);
    }
    return processes;
}

std::vector<Process> InputHandler::generateRandomProcesses(int count,
                                                          int max_arrival,
                                                          int min_burst,
                                                          int max_burst,
                                                          int max_priority) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::vector<Process> processes;

    std::uniform_int_distribution<> arrival_dist(0, max_arrival);
    std::uniform_int_distribution<> burst_dist(min_burst, max_burst);
    std::uniform_int_distribution<> priority_dist(0, max_priority);

    for (int i = 0; i < count; ++i) {
        processes.emplace_back(
            i + 1,                     // ID
            arrival_dist(gen),         // Arrival time
            burst_dist(gen),           // Burst time
            priority_dist(gen)         // Priority
        );
    }
    return processes;
}
./src/main.cpp
#include <iostream>
#include <memory>
#include "InputHandler.h"
#include "Scheduler.h"
#include "Metrics.h"

// Forward declarations
void showMenu();
std::unique_ptr<Scheduler> selectScheduler();

int main() {
    std::vector<Process> processes;
    int choice;

    // Input selection
    std::cout << "Choose input method:\n"
              << "1. Read from file\n"
              << "2. Generate random processes\n";
    std::cin >> choice;

    if (choice == 1) {
        std::string filename;
        std::cout << "Enter filename: ";
        std::cin >> filename;
        processes = InputHandler::readFromFile(filename);
    } else {
        int count, max_arrival, min_burst, max_burst, max_priority;
        std::cout << "Number of processes: ";
        std::cin >> count;
        // ... get other parameters ...
        processes = InputHandler::generateRandomProcesses(
            count, max_arrival, min_burst, max_burst, max_priority);
    }

    auto scheduler = selectScheduler();
    scheduler->simulate(processes);

    Metrics::printGanttChart(scheduler->timeline);
    Metrics::calculateMetrics(processes);

    return 0;
}

// Implement menu functions similarly...
./src/Priority.cpp

#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include "Process.h"
#include "Scheduler.h"




// Priority Scheduling (Non-preemptive)
class PriorityScheduler : public Scheduler {
public:
    void schedule() override {
        std::sort(processes.begin(), processes.end(),
            [](const Process& a, const Process& b) {
                return a.getArrivalTime() < b.getArrivalTime();
            });

        current_time = 0;
        std::priority_queue<Process*, std::vector<Process*>, 
            bool(*)(Process*, Process*)> ready_queue(
                [](Process* a, Process* b) {
                    return a->getPriority() > b->getPriority();
                });

        size_t next = 0;
        while (next < processes.size() || !ready_queue.empty()) {
            while (next < processes.size() && 
                   processes[next].getArrivalTime() <= current_time) {
                ready_queue.push(&processes[next]);
                next++;
            }

            if (ready_queue.empty()) {
                current_time = processes[next].getArrivalTime();
                continue;
            }

            Process* p = ready_queue.top();
            ready_queue.pop();

            p->updateWaitingTime(current_time - p->getArrivalTime());
            current_time += p->getBurstTime();
            p->setCompletionTime(current_time);

            Metrics::ProcessStats stats;
            stats.waiting_time = p->getWaitingTime();
            stats.turnaround_time = p->getTurnaroundTime();
            metrics.process_details[p->getId()] = stats;
        }
        calculate_metrics();
    }
};
./src/PriorityRR.cpp
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include "Process.h"
#include "Scheduler.h"





// Priority with Round Robin (per priority level)
class PriorityRRScheduler : public Scheduler {
    int quantum;
    std::map<int, std::queue<Process*>> queues; // Lower key = higher priority

public:
    PriorityRRScheduler(int q) : quantum(q) {}

    void schedule() override {
        std::sort(processes.begin(), processes.end(),
            [](const Process& a, const Process& b) {
                return a.getArrivalTime() < b.getArrivalTime();
            });

        current_time = 0;
        size_t next = 0;
        Process* current_process = nullptr;
        int remaining_quantum = 0;

        while (true) {
            // Add arrived processes
            while (next < processes.size() && 
                   processes[next].getArrivalTime() <= current_time) {
                int prio = processes[next].getPriority();
                queues[prio].push(&processes[next]);
                next++;
            }

            // Check for higher priority processes
            if (current_process) {
                auto it = queues.begin();
                while (it != queues.end() && it->first >= current_process->getPriority()) {
                    ++it;
                }
                if (it != queues.end() && !it->second.empty()) {
                    queues[current_process->getPriority()].push(current_process);
                    current_process = nullptr;
                }
            }

            // Find highest priority queue
            auto it = queues.begin();
            while (it != queues.end() && it->second.empty()) ++it;

            if (it == queues.end()) {
                if (next >= processes.size()) break;
                current_time = processes[next].getArrivalTime();
                continue;
            }

            Process* p = it->second.front();
            it->second.pop();

            int exec_time = std::min(quantum, p->getRemainingTime());
            p->setRemainingTime(p->getRemainingTime() - exec_time);
            current_time += exec_time;

            if (p->getRemainingTime() > 0) {
                queues[p->getPriority()].push(p);
            } else {
                p->setCompletionTime(current_time);
                p->updateWaitingTime(p->getTurnaroundTime() - p->getBurstTime());
                
                Metrics::ProcessStats stats;
                stats.waiting_time = p->getWaitingTime();
                stats.turnaround_time = p->getTurnaroundTime();
                metrics.process_details[p->getId()] = stats;
            }
        }
        calculate_metrics();
    }
};
./src/Process.cpp
#include "Process.h"

Process::Process(int id, int at, int bt, int prio)
    : id(id), arrival_time(at), burst_time(bt),
      priority(prio), remaining_time(bt),
      waiting_time(0), turnaround_time(0), completion_time(0) {}

// Getter implementations
int Process::getId() const { return id; }
int Process::getArrivalTime() const { return arrival_time; }
int Process::getBurstTime() const { return burst_time; }
int Process::getPriority() const { return priority; }
int Process::getRemainingTime() const { return remaining_time; }
int Process::getWaitingTime() const { return waiting_time; }
int Process::getTurnaroundTime() const { return turnaround_time; }
int Process::getCompletionTime() const { return completion_time; }

// Setter implementations
void Process::setRemainingTime(int rt) { remaining_time = rt; }
void Process::updateWaitingTime(int wt) { waiting_time += wt; }
void Process::setCompletionTime(int ct) {
    completion_time = ct;
    turnaround_time = completion_time - arrival_time;
}
./src/RR.cpp
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include "Process.h"
#include "Scheduler.h"





// Round Robin Scheduler
class RRScheduler : public Scheduler {
    int quantum;
public:
    RRScheduler(int q) : quantum(q) {}

    void schedule() override {
        std::sort(processes.begin(), processes.end(),
            [](const Process& a, const Process& b) {
                return a.getArrivalTime() < b.getArrivalTime();
            });

        current_time = 0;
        std::queue<Process*> ready_queue;
        size_t next = 0;

        while (next < processes.size() || !ready_queue.empty()) {
            while (next < processes.size() && 
                   processes[next].getArrivalTime() <= current_time) {
                ready_queue.push(&processes[next]);
                next++;
            }

            if (ready_queue.empty()) {
                current_time = processes[next].getArrivalTime();
                continue;
            }

            Process* p = ready_queue.front();
            ready_queue.pop();

            int time_exec = std::min(quantum, p->getRemainingTime());
            p->setRemainingTime(p->getRemainingTime() - time_exec);
            current_time += time_exec;

            while (next < processes.size() && 
                   processes[next].getArrivalTime() <= current_time) {
                ready_queue.push(&processes[next]);
                next++;
            }

            if (p->getRemainingTime() > 0) {
                ready_queue.push(p);
            } else {
                p->setCompletionTime(current_time);
                p->updateWaitingTime(p->getTurnaroundTime() - p->getBurstTime());
                
                Metrics::ProcessStats stats;
                stats.waiting_time = p->getWaitingTime();
                stats.turnaround_time = p->getTurnaroundTime();
                metrics.process_details[p->getId()] = stats;
            }
        }
        calculate_metrics();
    }
};
./src/SJF.cpp
#include "Scheduler.h"
#include <algorithm> // for std::sort
#include <queue>




// Shortest Job First (SJF) Scheduling Algorithm
// Shortest Job First (Non-preemptive)
class SJFScheduler : public Scheduler {
public:
    void schedule() override {
        std::sort(processes.begin(), processes.end(),
            [](const Process& a, const Process& b) {
                return a.getArrivalTime() < b.getArrivalTime();
            });

        current_time = 0;
        std::priority_queue<Process*, std::vector<Process*>, 
            bool(*)(Process*, Process*)> ready_queue(
                [](Process* a, Process* b) {
                    return a->getBurstTime() > b->getBurstTime();
                });

        size_t next = 0;
        while (next < processes.size() || !ready_queue.empty()) {
            while (next < processes.size() && 
                   processes[next].getArrivalTime() <= current_time) {
                ready_queue.push(&processes[next]);
                next++;
            }

            if (ready_queue.empty()) {
                current_time = processes[next].getArrivalTime();
                continue;
            }

            Process* p = ready_queue.top();
            ready_queue.pop();

            p->updateWaitingTime(current_time - p->getArrivalTime());
            current_time += p->getBurstTime();
            p->setCompletionTime(current_time);

            Metrics::ProcessStats stats;
            stats.waiting_time = p->getWaitingTime();
            stats.turnaround_time = p->getTurnaroundTime();
            metrics.process_details[p->getId()] = stats;
        }
        calculate_metrics();
    }
};
./test/
./test/test_input.txt

